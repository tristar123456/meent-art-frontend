{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable } from '@angular/core';\nvar DOC_ORIENTATION = /*#__PURE__*/(() => {\n  (function (DOC_ORIENTATION) {\n    DOC_ORIENTATION[DOC_ORIENTATION[\"Up\"] = 1] = \"Up\";\n    DOC_ORIENTATION[DOC_ORIENTATION[\"Down\"] = 3] = \"Down\";\n    DOC_ORIENTATION[DOC_ORIENTATION[\"Right\"] = 6] = \"Right\";\n    DOC_ORIENTATION[DOC_ORIENTATION[\"Left\"] = 8] = \"Left\";\n    DOC_ORIENTATION[DOC_ORIENTATION[\"UpMirrored\"] = 2] = \"UpMirrored\";\n    DOC_ORIENTATION[DOC_ORIENTATION[\"DownMirrored\"] = 4] = \"DownMirrored\";\n    DOC_ORIENTATION[DOC_ORIENTATION[\"LeftMirrored\"] = 5] = \"LeftMirrored\";\n    DOC_ORIENTATION[DOC_ORIENTATION[\"RightMirrored\"] = 7] = \"RightMirrored\";\n    DOC_ORIENTATION[DOC_ORIENTATION[\"Default\"] = 0] = \"Default\";\n    DOC_ORIENTATION[DOC_ORIENTATION[\"NotJpeg\"] = -1] = \"NotJpeg\";\n    DOC_ORIENTATION[DOC_ORIENTATION[\"NotDefined\"] = -2] = \"NotDefined\";\n  })(DOC_ORIENTATION || (DOC_ORIENTATION = {}));\n\n  return DOC_ORIENTATION;\n})();\nlet ImageCompress = /*#__PURE__*/(() => {\n  class ImageCompress {}\n\n  /**\r\n   * Get the correct Orientation value from tags, in order to write correctly in our canvas\r\n   */\n  ImageCompress.getOrientation = file => new Promise((resolve, reject) => {\n    try {\n      const reader = new FileReader();\n\n      reader.onload = () => {\n        const view = new DataView(reader.result);\n\n        if (view.getUint16(0, false) !== 0xFFD8) {\n          return resolve(DOC_ORIENTATION.NotDefined);\n        }\n\n        const length = view.byteLength;\n        let offset = 2;\n\n        while (offset < length) {\n          const marker = view.getUint16(offset, false);\n          offset += 2;\n\n          if (marker === 0xFFE1) {\n            if (view.getUint32(offset += 2, false) !== 0x45786966) {\n              return resolve(DOC_ORIENTATION.NotJpeg);\n            }\n\n            const little = view.getUint16(offset += 6, false) === 0x4949;\n            offset += view.getUint32(offset + 4, little);\n            const tags = view.getUint16(offset, little);\n            offset += 2;\n\n            for (let i = 0; i < tags; i++) {\n              if (view.getUint16(offset + i * 12, little) === 0x0112) {\n                return resolve(view.getUint16(offset + i * 12 + 8, little));\n              }\n            }\n          } else if ((marker & 0xFF00) !== 0xFF00) {\n            break;\n          } else {\n            offset += view.getUint16(offset, false);\n          }\n        }\n\n        return resolve(DOC_ORIENTATION.NotJpeg);\n      };\n\n      reader.readAsArrayBuffer(file);\n    } catch (e) {\n      return reject(DOC_ORIENTATION.Default);\n    }\n  });\n  /**\r\n   * return a promise with the new image data and image orientation\r\n   */\n\n\n  ImageCompress.uploadFile = (render, multiple = true) => new Promise(function (resolve, reject) {\n    ImageCompress.generateUploadInput(render, multiple).then(filesList => {\n      const files = Array.from(filesList);\n      const orientationPromises = files.map(file => ImageCompress.getOrientation(file));\n      const readerPromises = files.map(file => ImageCompress.fileToDataURL(file));\n      let orientationsResult = [];\n      Promise.all(orientationPromises).then(orientations => {\n        orientationsResult = orientations;\n        return Promise.all(readerPromises);\n      }).then(readerResult => {\n        if (multiple) {\n          const result = readerResult.map((image, index) => ({\n            image,\n            orientation: orientationsResult[index]\n          }));\n          resolve(result);\n        } else {\n          resolve({\n            image: readerResult[0],\n            orientation: orientationsResult[0]\n          });\n        }\n      });\n    });\n  });\n\n  ImageCompress.fileToDataURL = file => {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n\n      reader.onload = e => {\n        resolve(e.target.result);\n      };\n\n      try {\n        reader.readAsDataURL(file);\n      } catch (e) {\n        reject(`ngx-image-compress - probably no file have been selected: ${e}`);\n      }\n    });\n  };\n\n  ImageCompress.generateUploadInput = (render, multiple = true) => new Promise((resolve, reject) => {\n    var _a, _b;\n\n    const inputElement = render.createElement('input'); // should be fix the problem for safari/ios\n\n    (_b = (_a = document.getElementsByTagName('body')) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.append(inputElement);\n    render.setStyle(inputElement, 'display', 'none');\n    render.setProperty(inputElement, 'type', 'file');\n    render.setProperty(inputElement, 'accept', 'image/*');\n\n    if (multiple) {\n      render.setProperty(inputElement, 'multiple', 'true');\n    }\n\n    render.listen(inputElement, 'click', $event => {\n      $event.target.value = '';\n    });\n    render.listen(inputElement, 'change', $event => {\n      const files = $event.target.files;\n      resolve(files);\n    });\n    inputElement.click();\n  });\n\n  ImageCompress.compress = (imageDataUrlSource, orientation, render, ratio = 50, quality = 50, maxwidth = 0, maxheight = 0) => new Promise(function (resolve, reject) {\n    quality = quality / 100;\n    ratio = ratio / 100;\n    const sourceImage = new Image(); // important for safari: we need to wait for onload event\n\n    sourceImage.onload = () => {\n      const canvas = render.createElement('canvas');\n      const ctx = canvas.getContext('2d');\n\n      if (!ctx) {\n        return reject(`No canvas context available`);\n      }\n\n      let w = sourceImage.naturalWidth;\n      let h = sourceImage.naturalHeight;\n\n      if (orientation === DOC_ORIENTATION.Right || orientation === DOC_ORIENTATION.Left) {\n        const t = w;\n        w = h;\n        h = t;\n      }\n\n      let xratio = maxwidth ? maxwidth / w : 1;\n      let yratio = maxheight ? maxheight / h : 1;\n      ratio = Math.min(ratio, xratio, yratio);\n      canvas.width = w * ratio;\n      canvas.height = h * ratio;\n      const TO_RADIANS = Math.PI / 180;\n\n      if (orientation === DOC_ORIENTATION.Up) {\n        ctx.drawImage(sourceImage, 0, 0, canvas.width, canvas.height);\n      } else if (orientation === DOC_ORIENTATION.Right) {\n        ctx.save();\n        ctx.rotate(90 * TO_RADIANS);\n        ctx.translate(0, -canvas.width);\n        ctx.drawImage(sourceImage, 0, 0, canvas.height, canvas.width);\n        ctx.restore();\n      } else if (orientation === DOC_ORIENTATION.Left) {\n        ctx.save();\n        ctx.rotate(-90 * TO_RADIANS);\n        ctx.translate(-canvas.width, 0);\n        ctx.drawImage(sourceImage, 0, 0, canvas.height, canvas.width);\n        ctx.restore();\n      } else if (orientation === DOC_ORIENTATION.Down) {\n        ctx.save();\n        ctx.rotate(180 * TO_RADIANS);\n        ctx.translate(-canvas.width, -canvas.height);\n        ctx.drawImage(sourceImage, 0, 0, canvas.width, canvas.height);\n        ctx.restore();\n      } else {\n        // console.warn('ngx-image-compress - no orientation value found');\n        // same as default UP\n        ctx.drawImage(sourceImage, 0, 0, canvas.width, canvas.height);\n      }\n\n      const mime = imageDataUrlSource.substr(5, imageDataUrlSource.split(';')[0].length - 5); // TODO test on mime\n\n      const result = canvas.toDataURL(mime, quality);\n      resolve(result);\n    };\n\n    sourceImage.onerror = e => {\n      reject(e);\n    };\n\n    sourceImage.src = imageDataUrlSource;\n  });\n  /**\r\n   * helper to evaluate the compression rate\r\n   * @param imgString the image in base64 string format\r\n   */\n\n\n  ImageCompress.byteCount = imgString => encodeURI(imgString).split(/%..|./).length - 1;\n\n  return ImageCompress;\n})();\nlet NgxImageCompressService = /*#__PURE__*/(() => {\n  class NgxImageCompressService {\n    constructor(rendererFactory) {\n      this.DOC_ORIENTATION = DOC_ORIENTATION;\n      this.render = rendererFactory.createRenderer(null, null);\n    }\n\n    byteCount(image) {\n      return ImageCompress.byteCount(image);\n    }\n\n    getOrientation(file) {\n      return ImageCompress.getOrientation(file);\n    }\n\n    uploadFile() {\n      return ImageCompress.uploadFile(this.render, false);\n    }\n\n    uploadMultipleFiles() {\n      return ImageCompress.uploadFile(this.render, true);\n    }\n\n    compressFile(image, orientation, ratio = 50, quality = 50, maxwidth = 0, maxheight = 0) {\n      return ImageCompress.compress(image, orientation, this.render, ratio, quality, maxwidth, maxheight);\n    }\n\n  }\n\n  NgxImageCompressService.ɵfac = function NgxImageCompressService_Factory(t) {\n    return new (t || NgxImageCompressService)(i0.ɵɵinject(i0.RendererFactory2));\n  };\n\n  NgxImageCompressService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NgxImageCompressService,\n    factory: NgxImageCompressService.ɵfac,\n    providedIn: 'root'\n  });\n  return NgxImageCompressService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\r\n * Public API Surface of ngx-image-compress\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\n\nexport { DOC_ORIENTATION, NgxImageCompressService }; //# sourceMappingURL=ngx-image-compress.mjs.map","map":null,"metadata":{},"sourceType":"module"}
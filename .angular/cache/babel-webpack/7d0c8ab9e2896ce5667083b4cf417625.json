{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Version, isDevMode, Injectable } from '@angular/core';\nimport { getApps } from 'firebase/app';\nimport { queueScheduler, asyncScheduler, Observable } from 'rxjs';\nimport { tap, observeOn, subscribeOn } from 'rxjs/operators';\nconst VERSION = /*#__PURE__*/new Version('7.0.4');\nconst IS_HMR = !!module.hot;\n\nconst log = (level, ...args) => {\n  if (isDevMode() && typeof console !== 'undefined') {\n    console[level](...args);\n  }\n};\n\nfunction ɵcacheInstance(cacheKey, moduleName, appName, fn, deps) {\n  const [, instance, cachedDeps] = globalThis.ɵAngularfireInstanceCache.find(it => it[0] === cacheKey) || [];\n\n  if (instance) {\n    if (!matchDep(deps, cachedDeps)) {\n      log('error', `${moduleName} was already initialized on the ${appName} Firebase App with different settings.${IS_HMR ? ' You may need to reload as Firebase is not HMR aware.' : ''}`);\n      log('warn', {\n        is: deps,\n        was: cachedDeps\n      });\n    }\n\n    return instance;\n  } else {\n    const newInstance = fn();\n    globalThis.ɵAngularfireInstanceCache.push([cacheKey, newInstance, deps]);\n    return newInstance;\n  }\n}\n\nglobalThis.ɵAngularfireInstanceCache || (globalThis.ɵAngularfireInstanceCache = []);\n\nfunction ɵmemoizeInstance(fn, zone) {\n  const [, instance] = globalThis.ɵAngularfireInstanceCache.find(it => matchDep(it[0], fn)) || [];\n\n  if (instance) {\n    return instance;\n  } else {\n    // TODO catch and add HMR warning\n    const instance = zone.runOutsideAngular(() => fn());\n    globalThis.ɵAngularfireInstanceCache.push([fn, instance]);\n    return instance;\n  }\n}\n\nfunction matchDep(a, b) {\n  try {\n    return a.toString() === b.toString();\n  } catch (_) {\n    return a === b;\n  }\n}\n\nfunction ɵgetDefaultInstanceOf(identifier, provided, defaultApp) {\n  if (provided) {\n    // Was provide* only called once? If so grab that\n    if (provided.length === 1) {\n      return provided[0];\n    }\n\n    const providedUsingDefaultApp = provided.filter(it => it.app === defaultApp); // Was provide* only called once, using the default app? If so use that\n\n    if (providedUsingDefaultApp.length === 1) {\n      return providedUsingDefaultApp[0];\n    }\n  } // Grab the default instance from the defaultApp\n\n\n  const defaultAppWithContainer = defaultApp;\n  const provider = defaultAppWithContainer.container.getProvider(identifier);\n  return provider.getImmediate();\n}\n\nconst ɵgetAllInstancesOf = (identifier, app) => {\n  const apps = app ? [app] : getApps();\n  const instances = [];\n  apps.forEach(app => {\n    const provider = app.container.getProvider(identifier);\n    provider.instances.forEach(instance => {\n      if (!instances.includes(instance)) {\n        instances.push(instance);\n      }\n    });\n  });\n  return instances;\n};\n\nfunction noop() {}\n/**\n * Schedules tasks so that they are invoked inside the Zone that is passed in the constructor.\n */\n// tslint:disable-next-line:class-name\n\n\nclass ɵZoneScheduler {\n  constructor(zone, delegate = queueScheduler) {\n    this.zone = zone;\n    this.delegate = delegate;\n  }\n\n  now() {\n    return this.delegate.now();\n  }\n\n  schedule(work, delay, state) {\n    const targetZone = this.zone; // Wrap the specified work function to make sure that if nested scheduling takes place the\n    // work is executed in the correct zone\n\n    const workInZone = function (state) {\n      targetZone.runGuarded(() => {\n        work.apply(this, [state]);\n      });\n    }; // Scheduling itself needs to be run in zone to ensure setInterval calls for async scheduling are done\n    // inside the correct zone. This scheduler needs to schedule asynchronously always to ensure that\n    // firebase emissions are never synchronous. Specifying a delay causes issues with the queueScheduler delegate.\n\n\n    return this.delegate.schedule(workInZone, delay, state);\n  }\n\n}\n\nclass BlockUntilFirstOperator {\n  constructor(zone) {\n    this.zone = zone;\n    this.task = null;\n  }\n\n  call(subscriber, source) {\n    const unscheduleTask = this.unscheduleTask.bind(this);\n    this.task = this.zone.run(() => Zone.current.scheduleMacroTask('firebaseZoneBlock', noop, {}, noop, noop));\n    return source.pipe(tap({\n      next: unscheduleTask,\n      complete: unscheduleTask,\n      error: unscheduleTask\n    })).subscribe(subscriber).add(unscheduleTask);\n  }\n\n  unscheduleTask() {\n    // maybe this is a race condition, invoke in a timeout\n    // hold for 10ms while I try to figure out what is going on\n    setTimeout(() => {\n      if (this.task != null && this.task.state === 'scheduled') {\n        this.task.invoke();\n        this.task = null;\n      }\n    }, 10);\n  }\n\n} // tslint:disable-next-line:class-name\n\n\nlet ɵAngularFireSchedulers = /*#__PURE__*/(() => {\n  class ɵAngularFireSchedulers {\n    constructor(ngZone) {\n      this.ngZone = ngZone;\n      this.outsideAngular = ngZone.runOutsideAngular(() => new ɵZoneScheduler(Zone.current));\n      this.insideAngular = ngZone.run(() => new ɵZoneScheduler(Zone.current, asyncScheduler));\n      globalThis.ɵAngularFireScheduler || (globalThis.ɵAngularFireScheduler = this);\n    }\n\n  }\n\n  ɵAngularFireSchedulers.ɵfac = function ɵAngularFireSchedulers_Factory(t) {\n    return new (t || ɵAngularFireSchedulers)(i0.ɵɵinject(i0.NgZone));\n  };\n\n  ɵAngularFireSchedulers.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ɵAngularFireSchedulers,\n    factory: ɵAngularFireSchedulers.ɵfac,\n    providedIn: 'root'\n  });\n  return ɵAngularFireSchedulers;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction getSchedulers() {\n  const schedulers = globalThis.ɵAngularFireScheduler;\n\n  if (!schedulers) {\n    throw new Error('AngularFireModule has not been provided');\n  }\n\n  return schedulers;\n}\n\nfunction runOutsideAngular(fn) {\n  return getSchedulers().ngZone.runOutsideAngular(() => fn());\n}\n\nfunction run(fn) {\n  return getSchedulers().ngZone.run(() => fn());\n}\n\nfunction observeOutsideAngular(obs$) {\n  return obs$.pipe(observeOn(getSchedulers().outsideAngular));\n}\n\nfunction observeInsideAngular(obs$) {\n  return obs$.pipe(observeOn(getSchedulers().insideAngular));\n}\n\nfunction keepUnstableUntilFirst(obs$) {\n  const scheduler = getSchedulers();\n  return ɵkeepUnstableUntilFirstFactory(getSchedulers())(obs$);\n}\n/**\n * Operator to block the zone until the first value has been emitted or the observable\n * has completed/errored. This is used to make sure that universal waits until the first\n * value from firebase but doesn't block the zone forever since the firebase subscription\n * is still alive.\n */\n\n\nfunction ɵkeepUnstableUntilFirstFactory(schedulers) {\n  return function keepUnstableUntilFirst(obs$) {\n    obs$ = obs$.lift(new BlockUntilFirstOperator(schedulers.ngZone));\n    return obs$.pipe( // Run the subscribe body outside of Angular (e.g. calling Firebase SDK to add a listener to a change event)\n    subscribeOn(schedulers.outsideAngular), // Run operators inside the angular zone (e.g. side effects via tap())\n    observeOn(schedulers.insideAngular) // INVESTIGATE https://github.com/angular/angularfire/pull/2315\n    // share()\n    );\n  };\n}\n\nconst zoneWrapFn = (it, macrotask) => {\n  const _this = this; // function() is needed for the arguments object\n  // tslint:disable-next-line:only-arrow-functions\n\n\n  return function () {\n    if (macrotask) {\n      setTimeout(() => {\n        if (macrotask.state === 'scheduled') {\n          macrotask.invoke();\n        }\n      }, 10);\n    }\n\n    return run(() => it.apply(_this, arguments));\n  };\n};\n\nconst ɵzoneWrap = (it, blockUntilFirst) => {\n  // function() is needed for the arguments object\n  // tslint:disable-next-line:only-arrow-functions\n  return function () {\n    let macrotask; // if this is a callback function, e.g, onSnapshot, we should create a microtask and invoke it\n    // only once one of the callback functions is tripped.\n\n    for (let i = 0; i < arguments.length; i++) {\n      if (typeof arguments[i] === 'function') {\n        if (blockUntilFirst) {\n          macrotask || (macrotask = run(() => Zone.current.scheduleMacroTask('firebaseZoneBlock', noop, {}, noop, noop)));\n        } // TODO create a microtask to track callback functions\n\n\n        arguments[i] = zoneWrapFn(arguments[i], macrotask);\n      }\n    }\n\n    const ret = runOutsideAngular(() => it.apply(this, arguments));\n\n    if (!blockUntilFirst) {\n      if (ret instanceof Observable) {\n        const schedulers = getSchedulers();\n        return ret.pipe(subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));\n      } else {\n        return run(() => ret);\n      }\n    }\n\n    if (ret instanceof Observable) {\n      return ret.pipe(keepUnstableUntilFirst);\n    } else if (ret instanceof Promise) {\n      return run(() => new Promise((resolve, reject) => ret.then(it => run(() => resolve(it)), reason => run(() => reject(reason)))));\n    } else if (typeof ret === 'function' && macrotask) {\n      // Handle unsubscribe\n      // function() is needed for the arguments object\n      // tslint:disable-next-line:only-arrow-functions\n      return function () {\n        setTimeout(() => {\n          if (macrotask && macrotask.state === 'scheduled') {\n            macrotask.invoke();\n          }\n        }, 10);\n        return ret.apply(this, arguments);\n      };\n    } else {\n      // TODO how do we handle storage uploads in Zone? and other stuff with cancel() etc?\n      return run(() => ret);\n    }\n  };\n};\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { VERSION, keepUnstableUntilFirst, observeInsideAngular, observeOutsideAngular, ɵAngularFireSchedulers, ɵZoneScheduler, ɵcacheInstance, ɵgetAllInstancesOf, ɵgetDefaultInstanceOf, ɵkeepUnstableUntilFirstFactory, ɵmemoizeInstance, ɵzoneWrap }; //# sourceMappingURL=angular-fire.js.map","map":null,"metadata":{},"sourceType":"module"}
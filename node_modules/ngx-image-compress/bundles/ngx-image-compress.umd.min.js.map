{"version":3,"sources":["../../../projects/ngx-image-compress/src/lib/DOC_ORIENTATION.ts","../../../projects/ngx-image-compress/src/lib/image-compress.ts","../../../projects/ngx-image-compress/src/lib/ngx-image-compress.service.ts"],"names":["DOC_ORIENTATION","Up","Down","Right","Left","UpMirrored","DownMirrored","LeftMirrored","RightMirrored","NotJpeg","NotDefined","ImageCompress","getOrientation","file","callback","reader","FileReader","onload","$event","view","DataView","getUint16","length","byteLength","offset","marker","getUint32","little","tags","i","readAsArrayBuffer","e","uploadFile","render","Promise","resolve","reject","inputElement","createElement","_b","_a","document","getElementsByTagName","append","setStyle","setProperty","listen","target","value","files","myReader","onloadend","orientation","image","readAsDataURL","console","warn","click","compress","imageDataUrlSource","ratio","quality","sourceImage","Image","w","h","canvas","ctx","getContext","naturalWidth","naturalHeight","t","width","height","TO_RADIANS","Math","PI","drawImage","save","rotate","translate","restore","mime","substr","split","result","toDataURL","src","byteCount","s","encodeURI","NgxImageCompressService","rendererFactory","this","createRenderer","prototype","compressFile","Injectable","RendererFactory2"],"mappings":"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","sourcesContent":["export enum DOC_ORIENTATION {\n  Up = 1,\n  Down = 3,\n  Right = 6,\n  Left = 8,\n  UpMirrored = 2,\n  DownMirrored = 4,\n  LeftMirrored = 5,\n  RightMirrored = 7,\n  NotJpeg = -1,\n  NotDefined = -2\n}\n","import {Renderer2} from '@angular/core';\nimport {DOC_ORIENTATION} from './DOC_ORIENTATION';\n\nexport class ImageCompress {\n\n\n  /**\n   * Get the correct Orientation value from tags, in order to write correctly in our canvas\n   */\n  static getOrientation(file: File, callback: (result: DOC_ORIENTATION) => void) {\n    const reader = new FileReader();\n    try {\n      reader.onload = function ($event) {\n        const view = new DataView(reader.result as ArrayBuffer);\n        if (view.getUint16(0, false) !== 0xFFD8) {\n          return callback(-2);\n        }\n        const length = view.byteLength;\n        let offset = 2;\n        while (offset < length) {\n          const marker = view.getUint16(offset, false);\n          offset += 2;\n          if (marker === 0xFFE1) {\n            if (view.getUint32(offset += 2, false) !== 0x45786966) {\n              return callback(-1);\n            }\n            const little = view.getUint16(offset += 6, false) === 0x4949;\n            offset += view.getUint32(offset + 4, little);\n            const tags = view.getUint16(offset, little);\n            offset += 2;\n            for (let i = 0; i < tags; i++) {\n              if (view.getUint16(offset + (i * 12), little) === 0x0112) {\n                return callback(view.getUint16(offset + (i * 12) + 8, little));\n              }\n            }\n          } else if ((marker & 0xFF00) !== 0xFF00) {\n            break;\n          } else {\n            offset += view.getUint16(offset, false);\n          }\n        }\n        return callback(-1);\n      };\n      reader.readAsArrayBuffer(file);\n    } catch (e) {\n      return callback(0);\n    }\n\n  }\n\n\n  /**\n   * return a promise with the new image data and image orientation\n   */\n  static uploadFile(render: Renderer2): Promise<{ image: string, orientation: DOC_ORIENTATION }> {\n\n    const promise: Promise<{ image: string, orientation: DOC_ORIENTATION }> = new Promise(function (resolve, reject) {\n\n      const inputElement = render.createElement('input');\n      // should be fix the problem for safari/ios\n      document.getElementsByTagName('body')?.[0]?.append(inputElement);\n      render.setStyle(inputElement, 'display', 'none');\n      render.setProperty(inputElement, 'type', 'file');\n      render.setProperty(inputElement, 'accept', 'image/*');\n\n      render.listen(inputElement, 'click', ($event) => {\n        // console.log('MouseEvent:', $event);\n        // console.log('Input:', $event.target);\n        $event.target.value = null;\n      });\n\n\n      render.listen(inputElement, 'change', ($event) => {\n        const file: File = $event.target.files[0];\n\n        const myReader: FileReader = new FileReader();\n\n        myReader.onloadend = (e) => {\n          try {\n            ImageCompress.getOrientation(file, orientation => {\n              resolve({image: myReader.result as string, orientation});\n            });\n          } catch (e) {\n            // console.log(`ngx-image-compress error ${e}`);\n            reject(e);\n          }\n        };\n\n        try {\n          myReader.readAsDataURL(file);\n        } catch (e) {\n          console.warn(`ngx-image-compress - probably no file have been selected: ${e}`);\n          reject('No file selected');\n        }\n\n      });\n      inputElement.click();\n\n    });\n\n    return promise;\n  }\n\n\n  static compress(imageDataUrlSource: string,\n                  orientation: DOC_ORIENTATION,\n                  render: Renderer2,\n                  ratio: number = 50,\n                  quality: number = 50): Promise<string> {\n\n    const promise: Promise<string> = new Promise(function (resolve, reject) {\n\n      quality = quality / 100;\n      ratio = ratio / 100;\n      const sourceImage = new Image();\n\n      // important for safari: we need to wait for onload event\n      sourceImage.onload = function () {\n        const canvas: HTMLCanvasElement = render.createElement('canvas');\n        const ctx: CanvasRenderingContext2D = canvas.getContext('2d');\n\n        let w, h;\n        w = sourceImage.naturalWidth;\n        h = sourceImage.naturalHeight;\n\n        if (orientation === DOC_ORIENTATION.Right || orientation === DOC_ORIENTATION.Left) {\n          const t = w;\n          w = h;\n          h = t;\n        }\n\n        canvas.width = w * ratio;\n        canvas.height = h * ratio;\n\n\n        const TO_RADIANS = Math.PI / 180;\n\n        if (orientation === DOC_ORIENTATION.Up) {\n\n          ctx.drawImage(sourceImage, 0, 0, canvas.width, canvas.height);\n\n        } else if (orientation === DOC_ORIENTATION.Right) {\n\n          ctx.save();\n          ctx.rotate(90 * TO_RADIANS);\n          ctx.translate(0, -canvas.width);\n          ctx.drawImage(sourceImage, 0, 0, canvas.height, canvas.width);\n          ctx.restore();\n\n        } else if (orientation === DOC_ORIENTATION.Left) {\n\n          ctx.save();\n          ctx.rotate(-90 * TO_RADIANS);\n          ctx.translate(-canvas.width, 0);\n          ctx.drawImage(sourceImage, 0, 0, canvas.height, canvas.width);\n          ctx.restore();\n\n        } else if (orientation === DOC_ORIENTATION.Down) {\n\n          ctx.save();\n          ctx.rotate(180 * TO_RADIANS);\n          ctx.translate(-canvas.width, -canvas.height);\n          ctx.drawImage(sourceImage, 0, 0, canvas.width, canvas.height);\n          ctx.restore();\n\n        } else {\n          // console.warn('ngx-image-compress - no orientation value found');\n          // same as default UP\n          ctx.drawImage(sourceImage, 0, 0, canvas.width, canvas.height);\n        }\n\n\n        const mime = imageDataUrlSource.substr(5, imageDataUrlSource.split(';')[0].length - 5);\n        // TODO test on mime\n        const result = canvas.toDataURL(mime, quality);\n\n        resolve(result);\n\n      };\n\n      sourceImage.src = imageDataUrlSource;\n\n    });\n\n    return promise;\n  }\n\n\n  /**\n   * helper to evaluate the compression rate\n   * @param s the image in base64 string format\n   */\n  static byteCount(s: string): number {\n    return encodeURI(s).split(/%..|./).length - 1;\n  }\n\n}\n","import {Injectable, Renderer2, RendererFactory2} from '@angular/core';\nimport {ImageCompress} from './image-compress';\nimport {DOC_ORIENTATION} from './DOC_ORIENTATION';\n\n@Injectable()\nexport class NgxImageCompressService {\n\n  private render: Renderer2;\n\n  public DOC_ORIENTATION = DOC_ORIENTATION;\n\n  constructor(rendererFactory: RendererFactory2) {\n    this.render = rendererFactory.createRenderer(null, null);\n  }\n\n  public byteCount(image) {\n    return ImageCompress.byteCount(image);\n  }\n\n  /** Get the correct Orientation value from the EXIF tags in the specified file. */\n  public getOrientation(file: File): Promise<DOC_ORIENTATION> {\n    return new Promise<DOC_ORIENTATION>((resolve) => {\n      ImageCompress.getOrientation(file, (result) => {\n        resolve(result);\n      });\n    });\n  }\n\n  public uploadFile(): Promise<{ image: string, orientation: DOC_ORIENTATION }> {\n    return ImageCompress.uploadFile(this.render);\n  }\n\n  public compressFile(image: string, orientation: DOC_ORIENTATION, ratio: number = 50, quality: number = 50): Promise<string> {\n    return ImageCompress.compress(image, orientation, this.render, ratio, quality);\n  }\n\n}\n"]}